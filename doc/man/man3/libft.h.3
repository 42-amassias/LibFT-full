.TH "includes/libft.h" 3 "Infini-3D" \" -*- nroff -*-
.ad l
.nh
.SH NAME
includes/libft.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBs_list\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBs_list\fP \fBt_list\fP"
.br
.ti -1c
.RI "typedef int(* \fBt_comparator\fP) (void *, void *)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBft_isalpha\fP (int c)"
.br
.RI "Tells whether or not \fCc\fP is a letter\&. "
.ti -1c
.RI "int \fBft_isdigit\fP (int c)"
.br
.RI "Tells whether or not \fCc\fP is a digit\&. "
.ti -1c
.RI "int \fBft_isalnum\fP (int c)"
.br
.RI "Tells whether or not \fCc\fP is a letter or a digit\&. "
.ti -1c
.RI "int \fBft_isascii\fP (int c)"
.br
.RI "Tells whether or not \fCc\fP is an ascii character\&. "
.ti -1c
.RI "int \fBft_isprint\fP (int c)"
.br
.RI "Tells whether or not \fCc\fP is printable\&. "
.ti -1c
.RI "int \fBft_toupper\fP (int c)"
.br
.RI "If \fCc\fP is a letter, converts it to uppercase\&. "
.ti -1c
.RI "int \fBft_tolower\fP (int c)"
.br
.RI "If \fCc\fP is a letter, converts it to lowercase\&. "
.ti -1c
.RI "size_t \fBft_strlen\fP (const char *str)"
.br
.RI "Calculates th length of \fCstr\fP\&. "
.ti -1c
.RI "void * \fBft_memset\fP (void *ptr, int c, size_t n)"
.br
.RI "Sets \fCn\fP bytes of \fCptr\fP to \fCc\fP\&. "
.ti -1c
.RI "void \fBft_bzero\fP (void *ptr, size_t n)"
.br
.RI "Writes \fCn\fP zeros ('\\0') to \fCptr\fP\&. "
.ti -1c
.RI "void * \fBft_memcpy\fP (void *dst, const void *src, size_t n)"
.br
.RI "Copies \fCn\fP bytes of \fCsrc\fP to \fCdst\fP\&. The memory areas mus not overlap\&. Use \fCft_memmove\fP if the memory areas do overlap\&. "
.ti -1c
.RI "void * \fBft_memmove\fP (void *dst, const void *src, size_t n)"
.br
.RI "copies \fCn\fP bytes from memory area \fCsrc\fP to memory area \fCdst\fP\&. The memory areas may overlap: copying takes place as though the bytes in \fCsrc\fP are first copied into a temporary array that does not overlap \fCsrc\fP or \fCdst\fP, and the bytes are then copied from the temporary array to \fCdst\fP\&. "
.ti -1c
.RI "size_t \fBft_strlcpy\fP (char *dst, const char *src, size_t size)"
.br
.RI "Copies \fCsrc\fP to \fCdst\fP\&. Takes the full \fCsize\fP of \fCdst\fP and guarantee to NUL-terminate the result (as long as \fCsize\fP is larger than 0)\&. Note that a byte for the NUL should be included in \fCsize\fP\&. Can only operate on true 'C' strings\&. \fCsrc\fP must be NUL-terminated\&. Copies up to \fCsize - 1\fP characters from \fCsrc\fP to \fCdst\fP, NUL-terminating the result\&. "
.ti -1c
.RI "size_t \fBft_strlcat\fP (char *dst, const char *src, size_t size)"
.br
.RI "Concatenate \fCstr\fP to \fCdst\fP\&. Takes the full \fCsize\fP of \fCdst\fP and guarantee to NUL-terminate the result (as long as there is at least one byte free in \fCdst\fP)\&. Note that a byte for the NUL should be included in \fCsize\fP\&. Can only operate on true “C” strings\&. This means that both \fCsrc\fP and \fCdst\fP must be NUL-terminated\&. Appends the NUL-terminated string \fCsrc\fP to the end of \fCdst\fP\&. It will append at most \fCsize - ft_strlen(dst) - 1\fP bytes, NUL-terminating the result\&. "
.ti -1c
.RI "char * \fBft_strchr\fP (const char *str, int c)"
.br
.RI "Returns a pointer to the first occurence of \fCc\fP in \fCstr\fP if it exists, \fCNULL\fP otherwise\&. "
.ti -1c
.RI "char * \fBft_strrchr\fP (const char *str, int c)"
.br
.RI "Returns a pointer to the last occurence of \fCc\fP in \fCstr\fP if it exists, \fCNULL\fP otherwise\&. "
.ti -1c
.RI "int \fBft_strncmp\fP (const char *str_1, const char *str_2, size_t n)"
.br
.RI "Compares with the lexical order the \fCn\fP first characters of \fCstr_1\fP and \fCstr_2\fP\&. "
.ti -1c
.RI "void * \fBft_memchr\fP (const void *ptr, int c, size_t n)"
.br
.RI "Returns a pointer to the first occurence of the byte \fCc\fP in \fCptr\fP if it exists, \fCNULL\fP otherwise\&. "
.ti -1c
.RI "int \fBft_memcmp\fP (const void *s1, const void *s2, size_t n)"
.br
.RI "Compares with the lexical order the \fCn\fP first bytes of \fCptr_1\fP and \fCptr_2\fP\&. "
.ti -1c
.RI "void \fBft_memswap\fP (void *a, void *b, size_t n)"
.br
.RI "Swaps \fCn\fP bytes of \fCa\fP and \fCb\fP\&. The memory areas must not overlap\&. "
.ti -1c
.RI "char * \fBft_strnstr\fP (const char *big, const char *little, size_t \fBlen\fP)"
.br
.RI "Locates the first occurrence of the null-terminated string \fClittle\fP in the string \fCbig\fP, where not more than \fClen\fP characters are searched\&. Characters that appear after a ‘\\0’ character are not searched\&. "
.ti -1c
.RI "char * \fBft_strdup\fP (const char *str)"
.br
.RI "Allocates (with malloc(3)) and returns a copy of \fCstr\fP\&. "
.ti -1c
.RI "char * \fBft_substr\fP (char const *str, unsigned int start, size_t \fBlen\fP)"
.br
.RI "Allocates (with malloc(3)) and returns a substring from the string \fCstr\fP\&. The substring begins at index \fCstart\fP and is of maximum size \fClen\fP\&. "
.ti -1c
.RI "char * \fBft_strjoin\fP (char const *str_1, char const *str_2)"
.br
.RI "Allocates (with malloc(3)) and returns a new string, which is the result of the concatenation of \fCstr_1\fP and \fCstr_2\fP\&. "
.ti -1c
.RI "char * \fBft_strtrim\fP (char const *str, char const *set)"
.br
.RI "Allocates (with malloc(3)) and returns a copy of \fCstr\fP with the characters specified in \fCset\fP removed from the beginning and the end of the string\&. "
.ti -1c
.RI "char ** \fBft_split\fP (char const *str, char delim_char)"
.br
.RI "Allocates (with malloc(3)) and returns an array of strings obtained by splitting \fCstr\fP using the character \fCdelim_char\fP as a delimiter\&. The array must end with a \fCNULL\fP pointer\&. "
.ti -1c
.RI "char * \fBft_itoa\fP (int n)"
.br
.RI "Allocates (with malloc(3)) and returns a string representing the integer received as an argument\&. Negative numbers must be handled\&. "
.ti -1c
.RI "char * \fBft_strmapi\fP (char const *s, char(*f)(unsigned int, char))"
.br
.RI "Applies the function \fCf\fP to each character of the string \fCstr\fP, and passing its index as first argument to create a new string (with malloc(3)) resulting from successive applications of \fCf\fP\&. "
.ti -1c
.RI "void \fBft_striteri\fP (char *str, void(*f)(unsigned int, char *))"
.br
.RI "Applies the function \fCf\fP on each character of the string \fCstr\fP, passing its index as first argument\&. Each character is passed by address to \fCf\fP to be modified if necessary\&. "
.ti -1c
.RI "int \fBft_atoi\fP (const char *str)"
.br
.RI "Converts the initial portion of the string pointed to by \fCstr\fP to an integer\&. "
.ti -1c
.RI "void * \fBft_calloc\fP (size_t nmemb, size_t size)"
.br
.RI "Allocates memory for an array of \fCnmemb\fP elements of size bytes each and returns a pointer to the allocated memory\&. The memory is set to zero\&. If \fCnmemb\fP or \fCsize\fP is 0, then calloc() returns either NULL, or a unique pointer value that can later be successfully passed to free()\&. If the multiplication of \fCnmemb\fP and \fCsize\fP would result in integer overflow, then calloc() returns \fCNULL\fP and sets \fCerrno\fP to \fCEINOMEM\fP\&. "
.ti -1c
.RI "void \fBft_putchar_fd\fP (char c, int fd)"
.br
.RI "Outputs the character \fCc\fP to the given file descriptor\&. "
.ti -1c
.RI "void \fBft_putstr_fd\fP (char *str, int fd)"
.br
.RI "Outputs the string \fCstr\fP to the given file descriptor\&. "
.ti -1c
.RI "void \fBft_putendl_fd\fP (char *str, int fd)"
.br
.RI "Outputs the string \fCstr\fP to the given file descriptor followed by a newline\&. "
.ti -1c
.RI "void \fBft_putnbr_fd\fP (signed int n, int fd)"
.br
.RI "Outputs the signed integer \fCn\fP to the given file descriptor\&. "
.ti -1c
.RI "\fBt_list\fP * \fBft_lstnew\fP (void *content)"
.br
.RI "Allocates (with malloc(3)) and returns a new node\&. The member variable \fCcontent\fP is initialized with the value of the parameter \fCcontent\fP\&. The variable \fCnext\fP is initialized to \fCNULL\fP\&. "
.ti -1c
.RI "void \fBft_lstadd_front\fP (\fBt_list\fP **lst, \fBt_list\fP *new)"
.br
.RI "Adds the node \fCnew\fP at the beginning of \fClist\fP\&. "
.ti -1c
.RI "int \fBft_lstsize\fP (\fBt_list\fP *list)"
.br
.RI "Counts the number of nodes in a list\&. "
.ti -1c
.RI "\fBt_list\fP * \fBft_lstlast\fP (\fBt_list\fP *list)"
.br
.RI "Returns the last node of the list\&. "
.ti -1c
.RI "void \fBft_lstadd_back\fP (\fBt_list\fP **list, \fBt_list\fP *new)"
.br
.RI "Adds the node \fCnew\fP at the end of the list\&. "
.ti -1c
.RI "void \fBft_lstdelone\fP (\fBt_list\fP *list, void(*del_fun)(void *))"
.br
.RI "Takes as a parameter a node and frees the memory of the node’s content using the function \fCdel_fun\fP given as a parameter and free the node\&. The memory of \fCnext\fP must not be freed\&. "
.ti -1c
.RI "void \fBft_lstclear\fP (\fBt_list\fP **list, void(*del_fun)(void *))"
.br
.RI "Deletes and frees the given node and every successor of that node, using the function \fCdel_fun\fP and free(3)\&. Finally, the pointer to the list must be set to \fCNULL\fP\&. "
.ti -1c
.RI "void \fBft_lstiter\fP (\fBt_list\fP *list, void(*f)(void *))"
.br
.RI "Iterates the list \fClist\fP and applies the function \fCf\fP on the content of each node\&. "
.ti -1c
.RI "\fBt_list\fP * \fBft_lstmap\fP (\fBt_list\fP *list, void *(*f)(void *), void(*del_fun)(void *))"
.br
.RI "Iterates the list \fClist\fP and applies the function \fCf\fP on the content of each node\&. Creates a new list resulting of the successive applications of the function \fCf\fP\&. The \fCdel_fun\fP function is used to delete the content of a node if needed\&. "
.ti -1c
.RI "void \fBft_qsort\fP (void *base, size_t nmemb, size_t size, \fBt_comparator\fP cmp)"
.br
.RI "Sorts \fCnmemb\fP elements of size \fCsize\fP of the list pointed by \fCbase\fP using \fCcmp\fP as the comparaison function\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "t_comparator"

.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP
\fBTodo\fP
.RS 4
Make description\&. 
.RE
.PP

.SS "\fBt_list\fP"

.PP

.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP
\fBTodo\fP
.RS 4
Make documentation\&. 
.RE
.PP
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP
\fBTodo\fP
.RS 4
Make description\&. 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "int ft_atoi (const char * str)"

.PP
Converts the initial portion of the string pointed to by \fCstr\fP to an integer\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to be converted\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The converted value\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_bzero (void * ptr, size_t n)"

.PP
Writes \fCn\fP zeros ('\\0') to \fCptr\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP A pointer to a memory area\&. 
.br
\fIn\fP The ammount of bytes to set to zero\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void * ft_calloc (size_t nmemb, size_t size)"

.PP
Allocates memory for an array of \fCnmemb\fP elements of size bytes each and returns a pointer to the allocated memory\&. The memory is set to zero\&. If \fCnmemb\fP or \fCsize\fP is 0, then calloc() returns either NULL, or a unique pointer value that can later be successfully passed to free()\&. If the multiplication of \fCnmemb\fP and \fCsize\fP would result in integer overflow, then calloc() returns \fCNULL\fP and sets \fCerrno\fP to \fCEINOMEM\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fInmemb\fP The number of elements if the array\&. 
.br
\fIsize\fP The size in bytes of each element\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Return a pointer to the allocated memory or NULL if case of error\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_isalnum (int c)"

.PP
Tells whether or not \fCc\fP is a letter or a digit\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP A character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fCc\fP is a letter or a digit\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_isalpha (int c)"

.PP
Tells whether or not \fCc\fP is a letter\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP A character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fCc\fP is a letter\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_isascii (int c)"

.PP
Tells whether or not \fCc\fP is an ascii character\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP A character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fCc\fP is an ascii character\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_isdigit (int c)"

.PP
Tells whether or not \fCc\fP is a digit\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP A character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fCc\fP is a digit\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_isprint (int c)"

.PP
Tells whether or not \fCc\fP is printable\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP A character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not \fCc\fP is printable\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_itoa (int n)"

.PP
Allocates (with malloc(3)) and returns a string representing the integer received as an argument\&. Negative numbers must be handled\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP The integer to convert\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The string representing the integer or \fCNULL\fP if the allocation fails\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_lstadd_back (\fBt_list\fP ** list, \fBt_list\fP * new)"

.PP
Adds the node \fCnew\fP at the end of the list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The address of a pointer to the first link of a list\&. 
.br
\fInew\fP The address of a pointer to the node to be added to the list\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_lstadd_front (\fBt_list\fP ** lst, \fBt_list\fP * new)"

.PP
Adds the node \fCnew\fP at the beginning of \fClist\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The address of a pointer to the first link of a list\&. 
.br
\fInew\fP The address of a pointer to the node to be added to the list\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_lstclear (\fBt_list\fP ** list, void(*)(void *) del_fun)"

.PP
Deletes and frees the given node and every successor of that node, using the function \fCdel_fun\fP and free(3)\&. Finally, the pointer to the list must be set to \fCNULL\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The address of a pointer to a node\&. 
.br
\fIdel_fun\fP The address of the function used to delete the content of the node\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_lstdelone (\fBt_list\fP * list, void(*)(void *) del_fun)"

.PP
Takes as a parameter a node and frees the memory of the node’s content using the function \fCdel_fun\fP given as a parameter and free the node\&. The memory of \fCnext\fP must not be freed\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The node to free\&. 
.br
\fIdel_fun\fP The address of the function used to delete the content\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_lstiter (\fBt_list\fP * list, void(*)(void *) f)"

.PP
Iterates the list \fClist\fP and applies the function \fCf\fP on the content of each node\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The address of a pointer to a node\&. 
.br
\fIf\fP The address of the function used to iterate on the list\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "\fBt_list\fP * ft_lstlast (\fBt_list\fP * list)"

.PP
Returns the last node of the list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The beginning of the list\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Last node of the list\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "\fBt_list\fP * ft_lstmap (\fBt_list\fP * list, void *(*)(void *) f, void(*)(void *) del_fun)"

.PP
Iterates the list \fClist\fP and applies the function \fCf\fP on the content of each node\&. Creates a new list resulting of the successive applications of the function \fCf\fP\&. The \fCdel_fun\fP function is used to delete the content of a node if needed\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The address of a pointer to a node\&. 
.br
\fIf\fP The address of the function used to iterate on the list\&. 
.br
\fIdel_fun\fP The address of the function used to delete the content of a node if needed\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The new list or \fCNULL\fP if the allocation fail\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "\fBt_list\fP * ft_lstnew (void * content)"

.PP
Allocates (with malloc(3)) and returns a new node\&. The member variable \fCcontent\fP is initialized with the value of the parameter \fCcontent\fP\&. The variable \fCnext\fP is initialized to \fCNULL\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIcontent\fP The content to create the node with\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The new node\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_lstsize (\fBt_list\fP * list)"

.PP
Counts the number of nodes in a list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlist\fP The beginning of the list\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The length of the list\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void * ft_memchr (const void * ptr, int c, size_t n)"

.PP
Returns a pointer to the first occurence of the byte \fCc\fP in \fCptr\fP if it exists, \fCNULL\fP otherwise\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP A memory area\&. 
.br
\fIc\fP A byte\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the first occurence of the byte \fCc\fP in \fCptr\fP if it exists, \fCNULL\fP otherwise\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_memcmp (const void * s1, const void * s2, size_t n)"

.PP
Compares with the lexical order the \fCn\fP first bytes of \fCptr_1\fP and \fCptr_2\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr_1\fP A memory area\&. 
.br
\fIptr_2\fP A memory area\&. 
.br
\fIn\fP The max ammount of bytes to compare\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The lexical order of the two memory area\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void * ft_memcpy (void * dst, const void * src, size_t n)"

.PP
Copies \fCn\fP bytes of \fCsrc\fP to \fCdst\fP\&. The memory areas mus not overlap\&. Use \fCft_memmove\fP if the memory areas do overlap\&. 
.PP
\fBParameters\fP
.RS 4
\fIdst\fP A pointer to a memory area\&. 
.br
\fIsrc\fP A pointer to a memory area\&. 
.br
\fIn\fP The ammount of bytes to copy\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The \fCdst\fP pointer\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void * ft_memmove (void * dst, const void * src, size_t n)"

.PP
copies \fCn\fP bytes from memory area \fCsrc\fP to memory area \fCdst\fP\&. The memory areas may overlap: copying takes place as though the bytes in \fCsrc\fP are first copied into a temporary array that does not overlap \fCsrc\fP or \fCdst\fP, and the bytes are then copied from the temporary array to \fCdst\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIdst\fP A pointer to a memory area\&. 
.br
\fIsrc\fP A pointer to a memory area\&. 
.br
\fIn\fP The ammount of bytes to copy\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The \fCdst\fP pointer\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void * ft_memset (void * ptr, int c, size_t n)"

.PP
Sets \fCn\fP bytes of \fCptr\fP to \fCc\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP A pointer to a memory area\&. 
.br
\fIc\fP A byte\&. 
.br
\fIn\fP The ammount of bytes to set to \fCc\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The \fCptr\fP pointer\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_memswap (void * a, void * b, size_t n)"

.PP
Swaps \fCn\fP bytes of \fCa\fP and \fCb\fP\&. The memory areas must not overlap\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP A memory area\&. 
.br
\fIb\fP A memory area\&. 
.br
\fIn\fP The number of bytes to swap\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_putchar_fd (char c, int fd)"

.PP
Outputs the character \fCc\fP to the given file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP The character to output\&. 
.br
\fIfd\fP The file descriptor on which to write\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_putendl_fd (char * str, int fd)"

.PP
Outputs the string \fCstr\fP to the given file descriptor followed by a newline\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP 
.br
\fIfd\fP 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_putnbr_fd (signed int n, int fd)"

.PP
Outputs the signed integer \fCn\fP to the given file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP The integer to output\&. 
.br
\fIfd\fP The file descriptor on which to write\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_putstr_fd (char * str, int fd)"

.PP
Outputs the string \fCstr\fP to the given file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to output\&. 
.br
\fIfd\fP The file descriptor on which to write\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_qsort (void * base, size_t nmemb, size_t size, \fBt_comparator\fP cmp)"

.PP
Sorts \fCnmemb\fP elements of size \fCsize\fP of the list pointed by \fCbase\fP using \fCcmp\fP as the comparaison function\&. 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP A memory area\&. 
.br
\fInmemb\fP The number of elements to sort\&. 
.br
\fIsize\fP The size of one single element\&. 
.br
\fIcmp\fP The comparaison function\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char ** ft_split (char const * str, char delim_char)"

.PP
Allocates (with malloc(3)) and returns an array of strings obtained by splitting \fCstr\fP using the character \fCdelim_char\fP as a delimiter\&. The array must end with a \fCNULL\fP pointer\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to be split\&. 
.br
\fIdelim_char\fP The delimiter character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The array of new strings resulting from the split or \fCNULL\fP if the allocation fails\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_strchr (const char * str, int c)"

.PP
Returns a pointer to the first occurence of \fCc\fP in \fCstr\fP if it exists, \fCNULL\fP otherwise\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP A string\&. 
.br
\fIc\fP A character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the first occurence of \fCc\fP in \fCstr\fP if it exists, \fCNULL\fP otherwise\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_strdup (const char * str)"

.PP
Allocates (with malloc(3)) and returns a copy of \fCstr\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP A string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A copy of \fCstr\fP\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "void ft_striteri (char * str, void(*)(unsigned int, char *) f)"

.PP
Applies the function \fCf\fP on each character of the string \fCstr\fP, passing its index as first argument\&. Each character is passed by address to \fCf\fP to be modified if necessary\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string on which to iterate\&. 
.br
\fIf\fP The function to apply to each character\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_strjoin (char const * str_1, char const * str_2)"

.PP
Allocates (with malloc(3)) and returns a new string, which is the result of the concatenation of \fCstr_1\fP and \fCstr_2\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr_1\fP The prefix string\&. 
.br
\fIstr_2\fP The suffix string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The new string or \fCNULL\fP if the allocation fails\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "size_t ft_strlcat (char * dst, const char * src, size_t size)"

.PP
Concatenate \fCstr\fP to \fCdst\fP\&. Takes the full \fCsize\fP of \fCdst\fP and guarantee to NUL-terminate the result (as long as there is at least one byte free in \fCdst\fP)\&. Note that a byte for the NUL should be included in \fCsize\fP\&. Can only operate on true “C” strings\&. This means that both \fCsrc\fP and \fCdst\fP must be NUL-terminated\&. Appends the NUL-terminated string \fCsrc\fP to the end of \fCdst\fP\&. It will append at most \fCsize - ft_strlen(dst) - 1\fP bytes, NUL-terminating the result\&. 
.PP
\fBParameters\fP
.RS 4
\fIdst\fP A pointer to a memory area\&. 
.br
\fIsrc\fP A string\&. 
.br
\fIsize\fP The length of the string \fCft_strlcat\fP tries to create\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The initial length of \fCdst\fP plus the length of \fCsrc\fP\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "size_t ft_strlcpy (char * dst, const char * src, size_t size)"

.PP
Copies \fCsrc\fP to \fCdst\fP\&. Takes the full \fCsize\fP of \fCdst\fP and guarantee to NUL-terminate the result (as long as \fCsize\fP is larger than 0)\&. Note that a byte for the NUL should be included in \fCsize\fP\&. Can only operate on true 'C' strings\&. \fCsrc\fP must be NUL-terminated\&. Copies up to \fCsize - 1\fP characters from \fCsrc\fP to \fCdst\fP, NUL-terminating the result\&. 
.PP
\fBParameters\fP
.RS 4
\fIdst\fP A pointer to a memory area\&. 
.br
\fIsrc\fP A string\&. 
.br
\fIsize\fP The length of the string \fCft_strlcopy\fP tries to create\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The length of \fCsrc\fP\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "size_t ft_strlen (const char * str)"

.PP
Calculates th length of \fCstr\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP A string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The length of \fCstr\fP\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_strmapi (char const * s, char(*)(unsigned int, char) f)"

.PP
Applies the function \fCf\fP to each character of the string \fCstr\fP, and passing its index as first argument to create a new string (with malloc(3)) resulting from successive applications of \fCf\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string on which to iterate\&. 
.br
\fIf\fP The function to apply to each character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The string created from the successive applications of \fCf\fP\&. Returns \fCNULL\fP if the allocation fails\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_strncmp (const char * str_1, const char * str_2, size_t n)"

.PP
Compares with the lexical order the \fCn\fP first characters of \fCstr_1\fP and \fCstr_2\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr_1\fP A string\&. 
.br
\fIstr_2\fP A string\&. 
.br
\fIn\fP The max ammount of characters to compare\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The lexical order of the two string\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_strnstr (const char * big, const char * little, size_t len)"

.PP
Locates the first occurrence of the null-terminated string \fClittle\fP in the string \fCbig\fP, where not more than \fClen\fP characters are searched\&. Characters that appear after a ‘\\0’ character are not searched\&. 
.PP
\fBParameters\fP
.RS 4
\fIbig\fP The string to be searched\&. 
.br
\fIlittle\fP The string to search\&. 
.br
\fIlen\fP The size of the search\&. 
.RE
.PP
\fBReturns\fP
.RS 4
If \fClittle\fP is an empty string, \fCbig\fP is returned; if \fClittle\fP occurs nowhere in \fCbig\fP, \fCNULL\fP is returned; otherwise a pointer to the first character of the first occurrence of \fClittle\fP is returned\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_strrchr (const char * str, int c)"

.PP
Returns a pointer to the last occurence of \fCc\fP in \fCstr\fP if it exists, \fCNULL\fP otherwise\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP A string\&. 
.br
\fIc\fP A character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the last occurence of \fCc\fP in \fCstr\fP if it exists, \fCNULL\fP otherwise\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_strtrim (char const * str, char const * set)"

.PP
Allocates (with malloc(3)) and returns a copy of \fCstr\fP with the characters specified in \fCset\fP removed from the beginning and the end of the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to be split\&. 
.br
\fIset\fP The delimiter character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The array of new strings resulting from the split or \fCNULL\fP if the allocation fails\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "char * ft_substr (char const * str, unsigned int start, size_t len)"

.PP
Allocates (with malloc(3)) and returns a substring from the string \fCstr\fP\&. The substring begins at index \fCstart\fP and is of maximum size \fClen\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string from which to create the substring\&. 
.br
\fIstart\fP The start index of the substring in the string \fCstr\fP\&. 
.br
\fIlen\fP The maximum length of the substring\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The substring or \fCNULL\fP if the allocation fails\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SS "int ft_tolower (int c)"

.PP
If \fCc\fP is a letter, converts it to lowercase\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP a character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The transformes character\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP
\fBCopyright\fP
.RS 4
Copyright (c) 2023 
.RE
.PP

.SS "int ft_toupper (int c)"

.PP
If \fCc\fP is a letter, converts it to uppercase\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP a character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The transformes character\&. 
.RE
.PP
\fBAuthor\fP
.RS 4
amassias (amassias@student.42lehavre.fr) 
.RE
.PP
\fBDate\fP
.RS 4
2023-11-06 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Infini-3D from the source code\&.
